<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>PythonQt: Developer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="float:right; padding: 1em;">
  <a href="https://github.com/MeVisLab">
    <span style="color: #3e8cb7; text-decoration: none; vertical-align: middle;">github.com/MeVisLab</span>
    <img src="GitHub-Mark-64px.png" height="32" width="32" border="0" style="vertical-align: middle;"/>
  </a>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PythonQt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Developer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Interface"></a>
Interface</h1>
<p>The main interface to <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> is the <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> singleton. <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> needs to be initialized via <a class="el" href="classPythonQt.html#a2cc06e2e12ebd389504e3ce6a1751c3e">PythonQt::init()</a> once. Afterwards you communicate with the singleton via <a class="el" href="classPythonQt.html#a55184a6cb954afb65e2d6f9ae56b0b0a" title="get the singleton instance">PythonQt::self()</a>. <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> offers a complete Qt binding, which needs to be enabled via PythonQt_QtAll::init().</p>
<h1><a class="anchor" id="Datatype"></a>
Datatype Mapping</h1>
<p>The following table shows the mapping between Python and Qt objects: </p><table class="doxtable">
<tr>
<th>Qt/C++</th><th>Python </th></tr>
<tr>
<td>bool</td><td>bool </td></tr>
<tr>
<td>double</td><td>float </td></tr>
<tr>
<td>float</td><td>float </td></tr>
<tr>
<td>char/uchar,int/uint,short,ushort,QChar</td><td>integer </td></tr>
<tr>
<td>long</td><td>integer </td></tr>
<tr>
<td>ulong,longlong,ulonglong</td><td>long </td></tr>
<tr>
<td>QString</td><td>unicode string </td></tr>
<tr>
<td>QByteArray</td><td>QByteArray wrapper </td></tr>
<tr>
<td>char*</td><td>str </td></tr>
<tr>
<td>QStringList</td><td>tuple of unicode strings </td></tr>
<tr>
<td>QVariantList</td><td>tuple of objects </td></tr>
<tr>
<td>QVariantMap</td><td>dict of objects </td></tr>
<tr>
<td>QVariant</td><td>depends on type, see below </td></tr>
<tr>
<td>QSize, QRect and all other standard Qt QVariants</td><td>variant wrapper that supports complete API of the respective Qt classes </td></tr>
<tr>
<td>OwnRegisteredMetaType</td><td>C++ wrapper, optionally with additional information/wrapping provided by registerCPPClass() </td></tr>
<tr>
<td>QList&lt;AnyObject*&gt;</td><td>converts to a list of CPP wrappers </td></tr>
<tr>
<td>QVector&lt;AnyObject*&gt;</td><td>converts to a list of CPP wrappers </td></tr>
<tr>
<td>EnumType</td><td>Enum wrapper derived from python integer </td></tr>
<tr>
<td>QObject (and derived classes)</td><td>QObject wrapper </td></tr>
<tr>
<td>C++ object</td><td>CPP wrapper, either wrapped via <a class="el" href="classPythonQtCppWrapperFactory.html" title="Factory interface for C++ classes that can be wrapped by QObject objects.">PythonQtCppWrapperFactory</a> or just decorated with decorators </td></tr>
<tr>
<td>PyObject</td><td>PyObject </td></tr>
</table>
<p>PyObject is passed as direct pointer, which allows to pass/return any Python object directly to/from a Qt slot that uses PyObject* as its argument/return value. QVariants are mapped recursively as given above, e.g. a dictionary can contain lists of dictionaries of doubles. All Qt QVariant types are implemented, <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> supports the complete Qt API for these object.</p>
<h1><a class="anchor" id="QObject"></a>
QObject Wrapping</h1>
<p>All classes derived from QObject are automatically wrapped with a python wrapper class when they become visible to the Python interpreter. This can happen via</p><ul>
<li>the <a class="el" href="classPythonQt.html#a8134a601594d09b76aad66da3e75803d" title="add the given qObject to the python object as a variable with name (it can be removed via clearVariab...">PythonQt::addObject()</a> method</li>
<li>when a Qt <b>slot</b> returns a QObject derived object to python</li>
<li>when a Qt <b>signal</b> contains a QObject and is connected to a python function</li>
</ul>
<p>It is important that you call <a class="el" href="classPythonQt.html#a1d50946ef76058e9e9ca37e99cdc16a2" title="registers a QObject derived class to PythonQt (this is implicitly called by addObject as well)">PythonQt::registerClass()</a> for any QObject derived class that may become visible to Python, except when you add it via <a class="el" href="classPythonQt.html#a8134a601594d09b76aad66da3e75803d" title="add the given qObject to the python object as a variable with name (it can be removed via clearVariab...">PythonQt::addObject()</a>. This will register the complete parent hierachy of the registered class, so that when you register e.g. a QPushButton, QWidget will be registered as well (and all intermediate parents).</p>
<p>From Python, you can talk to the returned QObjects in a natural way by calling their slots and receiving the return values. You can also read/write all properties of the objects as if they where normal python properties.</p>
<p>In addition to this, the wrapped objects support</p><ul>
<li>className() - returns a string that reprents the classname of the QObject</li>
<li>help() - shows all properties, slots, enums, decorator slots and constructors of the object, in a printable form</li>
<li>delete() - deletes the object (use with care, especially if you passed the ownership to C++)</li>
<li>connect(signal, function) - connect the signal of the given object to a python function</li>
<li>connect(signal, qobject, slot) - connect the signal of the given object to a slot of another QObject</li>
<li>disconnect(signal, function) - disconnect the signal of the given object from a python function</li>
<li>disconnect(signal, qobject, slot) - disconnect the signal of the given object from a slot of another QObject</li>
<li>children() - returns the children of the object</li>
<li>setParent(QObject) - set the parent</li>
<li>QObject* parent() - get the parent</li>
</ul>
<p>The below example shows how to connect signals in Python:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># define a signal handler function</span></div><div class="line">def someFunction(flag):</div><div class="line">  print flag</div><div class="line"></div><div class="line"># button1 is a QPushButton that has been added to Python via addObject()</div><div class="line"># connect the clicked signal to a python function:</div><div class="line">button1.connect(<span class="stringliteral">&quot;clicked(bool)&quot;</span>, someFunction)</div></div><!-- fragment --><h1><a class="anchor" id="CPP"></a>
CPP Wrapping</h1>
<p>You can create dedicated wrapper QObjects for any C++ class. This is done by deriving from <a class="el" href="classPythonQtCppWrapperFactory.html" title="Factory interface for C++ classes that can be wrapped by QObject objects.">PythonQtCppWrapperFactory</a> and adding your factory via addWrapperFactory(). Whenever <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> encounters a CPP pointer (e.g. on a slot or signal) and it does not known it as a QObject derived class, it will create a generic CPP wrapper. So even unknown C++ objects can be passed through Python. If the wrapper factory supports the CPP class, a QObject wrapper will be created for each instance that enters Python. An alternative to a complete wrapper via the wrapper factory are decorators, see <a class="el" href="Developer.html#Decorators">Decorator slots</a></p>
<h1><a class="anchor" id="MetaObject"></a>
Meta Object/Class access</h1>
<p>For each known C++ class, <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> provides a Python class. These classes are visible inside of the "PythonQt" python module or in subpackages if a package is given when the class is registered.</p>
<p>A Meta class supports:</p>
<ul>
<li>access to all declared enum values</li>
<li>constructors</li>
<li>static methods</li>
<li>unbound non-static methods</li>
<li>help() and className()</li>
</ul>
<p>From within Python, you can import the module "PythonQt" to access these classes and the Qt namespace.</p>
<div class="fragment"><div class="line">from <a class="code" href="classPythonQt.html">PythonQt</a> <span class="keyword">import</span> QtCore</div><div class="line"></div><div class="line"><span class="preprocessor"># namespace access:</span></div><div class="line">print QtCore.Qt.AlignLeft</div><div class="line"></div><div class="line"><span class="preprocessor"># constructors</span></div><div class="line">a = QtCore.QSize(12,13)</div><div class="line">b = QtCore.QFont()</div><div class="line"></div><div class="line"><span class="preprocessor"># static method</span></div><div class="line">QtCore.QDate.currentDate()</div><div class="line"></div><div class="line"><span class="preprocessor"># enum value</span></div><div class="line"><span class="preprocessor">QtCore.QFont.UltraCondensed</span></div></div><!-- fragment --><h1><a class="anchor" id="Decorators"></a>
Decorator slots</h1>
<p><a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> introduces a new generic approach to extend any wrapped QObject or CPP object with</p>
<ul>
<li>constructors</li>
<li>destructors (for CPP objects)</li>
<li>additional slots</li>
<li>static slots (callable on both the Meta object and the instances)</li>
</ul>
<p>The idea behind decorators is that we wanted to make it as easy as possible to extend wrapped objects. Since we already have an implementation for invoking any Qt Slot from Python, it looked promising to use this approach for the extension of wrapped objects as well. This avoids that the <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> user needs to care about how Python arguments are mapped from/to Qt when he wants to create static methods, constructors and additional member functions.</p>
<p>The basic idea about decorators is to create a QObject derived class that implements slots which take one of the above roles (e.g. constructor, destructor etc.) via a naming convention. These slots are then assigned to other classes via the naming convention.</p>
<ul>
<li>SomeClassName* new_SomeClassName(...) - defines a constructor for "SomeClassName" that returns a new object of type SomeClassName (where SomeClassName can be any CPP class, not just QObject classes)</li>
<li>void delete_SomeClassName(SomeClassName* o) - defines a destructor, which should delete the passed in object o</li>
<li>anything static_SomeClassName_someMethodName(...) - defines a static method that is callable on instances and the meta class</li>
<li>anything someMethodName(SomeClassName* o, ...) - defines a slot that will be available on SomeClassName instances (and derived instances). When such a slot is called the first argument is the pointer to the instance and the rest of the arguments can be used to make a call on the instance.</li>
</ul>
<p>The below example shows all kinds of decorators in action:</p>
<div class="fragment"><div class="line"><span class="comment">// an example CPP object</span></div><div class="line"><span class="keyword">class </span>YourCPPObject {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  YourCPPObject(<span class="keywordtype">int</span> arg1, <span class="keywordtype">float</span> arg2) { a = arg1; b = arg2; }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> doSomething(<span class="keywordtype">int</span> arg1) { <span class="keywordflow">return</span> arg1*a*b; };</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> a;</div><div class="line">  <span class="keywordtype">float</span> b;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// an example decorator</span></div><div class="line"><span class="keyword">class </span>ExampleDecorator : <span class="keyword">public</span> QObject</div><div class="line">{</div><div class="line">  Q_OBJECT</div><div class="line"></div><div class="line"><span class="keyword">public</span> slots:</div><div class="line">  <span class="comment">// add a constructor to QSize that takes a QPoint</span></div><div class="line">  QSize* new_QSize(<span class="keyword">const</span> QPoint&amp; p) { <span class="keywordflow">return</span> <span class="keyword">new</span> QSize(p.x(), p.y()); }</div><div class="line"></div><div class="line">  <span class="comment">// add a constructor for QPushButton that takes a text and a parent widget</span></div><div class="line">  QPushButton* new_QPushButton(<span class="keyword">const</span> QString&amp; text, QWidget* parent=NULL) { <span class="keywordflow">return</span> <span class="keyword">new</span> QPushButton(text, parent); }</div><div class="line"></div><div class="line">  <span class="comment">// add a constructor for a CPP object</span></div><div class="line">  YourCPPObject* new_YourCPPObject(<span class="keywordtype">int</span> arg1, <span class="keywordtype">float</span> arg2) { <span class="keywordflow">return</span> <span class="keyword">new</span> YourCPPObject(arg1, arg2); }</div><div class="line"></div><div class="line">  <span class="comment">// add a destructor for a CPP object</span></div><div class="line">  <span class="keywordtype">void</span> delete_YourCPPObject(YourCPPObject* obj) { <span class="keyword">delete</span> obj; }</div><div class="line"></div><div class="line">  <span class="comment">// add a static method to QWidget</span></div><div class="line">  QWidget* static_QWidget_mouseGrabber() { <span class="keywordflow">return</span> QWidget::mouseGrabber(); }</div><div class="line"></div><div class="line">  <span class="comment">// add an additional slot to QWidget (make move() callable, which is not declared as a slot in QWidget)</span></div><div class="line">  <span class="keywordtype">void</span> move(QWidget* w, <span class="keyword">const</span> QPoint&amp; p) { w-&gt;move(p); }</div><div class="line"></div><div class="line">  <span class="comment">// add an additional slot to QWidget, overloading the above move method</span></div><div class="line">  <span class="keywordtype">void</span> move(QWidget* w, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { w-&gt;move(x,y); }</div><div class="line"></div><div class="line">  <span class="comment">// add a method to your own CPP object</span></div><div class="line">  <span class="keywordtype">int</span> doSomething(YourCPPObject* obj, <span class="keywordtype">int</span> arg1) { <span class="keywordflow">return</span> obj-&gt;doSomething(arg1); }</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">PythonQt::self()-&gt;addDecorators(<span class="keyword">new</span> ExampleDecorator());</div><div class="line"><a class="code" href="classPythonQt.html#a55184a6cb954afb65e2d6f9ae56b0b0a">PythonQt::self</a>()-&gt;<a class="code" href="classPythonQt.html#a97559c89bfed5f0f5bb47d7fc360a269">registerCPPClass</a>(<span class="stringliteral">&quot;YourCPPObject&quot;</span>);</div></div><!-- fragment --><p>After you have registered an instance of the above ExampleDecorator, you can do the following from Python (all these calls are mapped to the above decorator slots):</p>
<div class="fragment"><div class="line">from <a class="code" href="classPythonQt.html">PythonQt</a> <span class="keyword">import</span> QtCore, QtGui, YourCPPObject</div><div class="line"></div><div class="line"><span class="preprocessor"># call our new constructor of QSize</span></div><div class="line">size = QtCore.QSize(QPoint(1,2));</div><div class="line"></div><div class="line"><span class="preprocessor"># call our new QPushButton constructor</span></div><div class="line">button = QtGui.QPushButton(<span class="stringliteral">&quot;sometext&quot;</span>);</div><div class="line"></div><div class="line"><span class="preprocessor"># call the move slot (overload1)</span></div><div class="line">button.move(QPoint(0,0))</div><div class="line"></div><div class="line"><span class="preprocessor"># call the move slot (overload2)</span></div><div class="line">button.move(0,0)</div><div class="line"></div><div class="line"><span class="preprocessor"># call the static method</span></div><div class="line">grabber = QtGui.QWidget.mouseWrapper();</div><div class="line"></div><div class="line"><span class="preprocessor"># create a CPP object via constructor</span></div><div class="line">yourCpp = YourCPPObject(1,11.5)</div><div class="line"></div><div class="line"><span class="preprocessor"># call the wrapped method on CPP object</span></div><div class="line">print yourCpp.doSomething(1);</div><div class="line"></div><div class="line"><span class="preprocessor"># destructor will be called:</span></div><div class="line"><span class="preprocessor">yourCpp = None</span></div></div><!-- fragment --><h1><a class="anchor" id="Ownership"></a>
Ownership management</h1>
<p>In <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a>, each wrapped C++ object is either owned by Python or C++. When an object is created via a Python constructor, it is owned by Python by default. When an object is returned from a C++ API (e.g. a slot), it is owned by C++ by default. Since the Qt API contains various APIs that pass the ownership from/to other C++ objects, <a class="el" href="classPythonQt.html" title="The main interface to the Python Qt binding, realized as a singleton.">PythonQt</a> needs to keep track of such API calls. This is archieved by annotating arguments and return values in wrapper slots with magic templates:</p>
<ul>
<li><a class="el" href="classPythonQtPassOwnershipToCPP.html">PythonQtPassOwnershipToCPP</a></li>
<li><a class="el" href="classPythonQtPassOwnershipToPython.html">PythonQtPassOwnershipToPython</a></li>
<li><a class="el" href="classPythonQtNewOwnerOfThis.html">PythonQtNewOwnerOfThis</a></li>
</ul>
<p>These annotation templates work for since C++ pointer types. In addition to that, they work for QList&lt;AnyObject*&gt;, to pass the ownership for each object in the list.</p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">public</span> slots:</div><div class="line">  <a class="code" href="classPythonQtPassOwnershipToPython.html">PythonQtPassOwnershipToPython&lt;QGraphicsItem*&gt;</a> createNewItemOwnedByPython();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> addItemToCPP(<a class="code" href="classPythonQtPassOwnershipToPython.html">PythonQtPassOwnershipToPython&lt;QGraphicsItem*&gt;</a> item);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> addItemToCPP(<a class="code" href="classPythonQtPassOwnershipToPython.html">PythonQtPassOwnershipToPython</a>&lt;QList&lt;QGraphicsItem*&gt; &gt; items);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> addItemParent(QGraphicsItem* wrappedObject, <a class="code" href="classPythonQtNewOwnerOfThis.html">PythonQtNewOwnerOfThis&lt;QGraphicsItem*&gt;</a> parent);</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 21 2019 14:04:57 for PythonQt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
